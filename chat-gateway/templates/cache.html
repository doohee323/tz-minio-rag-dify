<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>대화 캐시 조회</title>
  <style>
    body { font-family: system-ui, sans-serif; margin: 1rem; }
    .filters { display: flex; flex-wrap: wrap; gap: 0.5rem; align-items: center; margin-bottom: 1rem; }
    .filters label { display: flex; align-items: center; gap: 0.25rem; }
    .filters input { padding: 0.35rem; }
    table { border-collapse: collapse; width: 100%; margin-top: 0.5rem; }
    th, td { border: 1px solid #ccc; padding: 0.4rem 0.6rem; text-align: left; }
    th { background: #f0f0f0; }
    tr:hover { background: #f9f9f9; }
    tr.pointer { cursor: pointer; }
    .msg-user { background: #e3f2fd; }
    .msg-assistant { background: #f3e5f5; }
    .messages { margin-top: 1rem; }
    .messages h3 { margin-bottom: 0.5rem; }
    .message { padding: 0.5rem; margin-bottom: 0.25rem; border-radius: 4px; white-space: pre-wrap; }
    .error { color: #c62828; }
    .empty { color: #666; }
  </style>
</head>
<body>
  <h1>대화 캐시 조회</h1>
  <p class="empty">시스템·사용자·기간으로 동기화된 대화를 조회합니다. API Key가 필요합니다.</p>

  <div class="filters">
    <label>API Key <input type="password" id="apiKey" placeholder="X-API-Key" value="{{ api_key }}"></label>
    <label>시스템 <input type="text" id="systemId" placeholder="예: cointutor"></label>
    <label>사용자 <input type="text" id="userId" placeholder="예: 12345"></label>
    <label>시작일 <input type="date" id="fromDate"></label>
    <label>종료일 <input type="date" id="toDate"></label>
    <button type="button" id="btnSearch">조회</button>
  </div>

  <div id="error" class="error"></div>
  <table id="tableConv">
    <thead>
      <tr>
        <th>시스템</th>
        <th>사용자</th>
        <th>대화명</th>
        <th>대화 시각</th>
        <th>동기화 시각</th>
      </tr>
    </thead>
    <tbody></tbody>
  </table>
  <p id="convEmpty" class="empty" style="display:none;">조건에 맞는 대화가 없습니다.</p>
  <p id="convEmptyHint" class="empty" style="display:none; margin-top: 0.5rem;">
    동기화된 대화가 없을 수 있습니다. (1) <strong>채팅 페이지</strong>(/chat?token=...)에서 대화한 뒤, 해당 탭을 열어두거나 닫으면 sync/me가 호출되어 DB에 저장됩니다. (2) 또는 <strong>POST /v1/sync</strong> (헤더 X-API-Key)를 호출하면 등록된 사용자 전체를 동기화합니다.
  </p>

  <div class="messages" id="messagesBox" style="display:none;">
    <h3>메시지: <span id="convTitle"></span></h3>
    <div id="messagesList"></div>
  </div>

  <script>
    const apiKeyEl = document.getElementById('apiKey');
    const systemIdEl = document.getElementById('systemId');
    const userIdEl = document.getElementById('userId');
    const fromDateEl = document.getElementById('fromDate');
    const toDateEl = document.getElementById('toDate');
    const btnSearch = document.getElementById('btnSearch');
    const errorEl = document.getElementById('error');
    const tableBody = document.querySelector('#tableConv tbody');
    const convEmpty = document.getElementById('convEmpty');
    const convEmptyHint = document.getElementById('convEmptyHint');
    const messagesBox = document.getElementById('messagesBox');
    const convTitle = document.getElementById('convTitle');
    const messagesList = document.getElementById('messagesList');

    function headers() {
      const key = apiKeyEl.value.trim();
      return key ? { 'X-API-Key': key } : {};
    }

    async function doSearch() {
      errorEl.textContent = '';
      const params = new URLSearchParams();
      if (systemIdEl.value.trim()) params.set('system_id', systemIdEl.value.trim());
      if (userIdEl.value.trim()) params.set('user_id', userIdEl.value.trim());
      if (fromDateEl.value) params.set('from_date', fromDateEl.value);
      if (toDateEl.value) params.set('to_date', toDateEl.value);
      try {
        const r = await fetch('/v1/cache/conversations?' + params.toString(), { headers: headers() });
        if (!r.ok) {
          const t = await r.text();
          throw new Error(t || 'API key가 필요하거나 오류가 발생했습니다.');
        }
        const data = await r.json();
        tableBody.innerHTML = '';
        convEmpty.style.display = data.length ? 'none' : 'block';
        convEmptyHint.style.display = data.length ? 'none' : 'block';
        messagesBox.style.display = 'none';
        data.forEach(c => {
          const tr = document.createElement('tr');
          tr.className = 'pointer';
          tr.dataset.conversationId = c.conversation_id;
          tr.dataset.name = (c.name || c.conversation_id) || '';
          tr.innerHTML = `
            <td>${escapeHtml(c.system_id)}</td>
            <td>${escapeHtml(c.user_id)}</td>
            <td>${escapeHtml(c.name || '-')}</td>
            <td>${c.created_at ? formatDate(c.created_at) : '-'}</td>
            <td>${c.synced_at ? formatDate(c.synced_at) : '-'}</td>
          `;
          tr.addEventListener('click', () => loadMessages(c.conversation_id, tr.dataset.name));
          tableBody.appendChild(tr);
        });
      } catch (e) {
        errorEl.textContent = e.message;
      }
    }

    btnSearch.addEventListener('click', doSearch);
    if (apiKeyEl.value.trim()) doSearch();

    async function loadMessages(conversationId, title) {
      errorEl.textContent = '';
      try {
        const r = await fetch(`/v1/cache/conversations/${encodeURIComponent(conversationId)}/messages`, { headers: headers() });
        if (!r.ok) throw new Error('메시지 조회 실패');
        const data = await r.json();
        convTitle.textContent = title || conversationId;
        messagesBox.style.display = 'block';
        messagesList.innerHTML = data.length ? data.map(m => `
          <div class="message msg-${m.role}">
            <strong>${m.role === 'user' ? '사용자' : '봇'}</strong> ${m.created_at ? formatDate(m.created_at) : ''}<br>
            ${escapeHtml(m.content || '')}
          </div>
        `).join('') : '<p class="empty">메시지 없음</p>';
      } catch (e) {
        errorEl.textContent = e.message;
      }
    }

    function escapeHtml(s) {
      const div = document.createElement('div');
      div.textContent = s;
      return div.innerHTML;
    }
    function formatDate(iso) {
      try {
        const d = new Date(iso);
        return isNaN(d.getTime()) ? iso : d.toLocaleString('ko-KR');
      } catch (_) { return iso; }
    }
  </script>
</body>
</html>
